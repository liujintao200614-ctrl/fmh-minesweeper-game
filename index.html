<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FMHä»£å¸ç®¡ç†é¢æ¿ Pro - æ™ºèƒ½é’±åŒ…è¿æ¥</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            box-shadow: 0 32px 64px rgba(0,0,0,0.15);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
        }
        
        .header h1 {
            font-size: 3em;
            margin-bottom: 12px;
            font-weight: 700;
        }
        
        .content { padding: 40px; }
        
        /* æ™ºèƒ½è¿æ¥é¢æ¿æ ·å¼ */
        .wallet-connection-panel {
            background: linear-gradient(135deg, #f8f9fd 0%, #e9ecef 100%);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 30px;
            border: 1px solid #e9ecef;
            position: relative;
            overflow: hidden;
        }
        
        .connection-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .connection-header h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        .connection-header p {
            color: #6b7280;
            font-size: 1.1em;
        }
        
        /* è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .connection-status {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            border-radius: 50px;
            font-weight: 600;
            transition: all 0.3s ease;
            min-width: 160px;
            justify-content: center;
        }
        
        .status-indicator.checking {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }
        
        .status-indicator.error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }
        
        .status-indicator.pending {
            background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
            color: #6b7280;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }
        
        .status-dot.animate {
            animation: blink 1s infinite;
        }
        
        /* è¯¦ç»†è¯Šæ–­é¢æ¿ */
        .diagnostic-panel {
            background: white;
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #e5e7eb;
            display: none;
        }
        
        .diagnostic-panel.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }
        
        .diagnostic-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .diagnostic-item:last-child {
            border-bottom: none;
        }
        
        .diagnostic-label {
            color: #374151;
            font-weight: 500;
        }
        
        .diagnostic-value {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .diagnostic-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        .diagnostic-icon.success {
            background: #10b981;
        }
        
        .diagnostic-icon.error {
            background: #ef4444;
        }
        
        .diagnostic-icon.loading {
            background: #fbbf24;
            animation: spin 1s linear infinite;
        }
        
        /* è¿æ¥æŒ‰é’® */
        .connect-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 18px 48px;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
            min-width: 200px;
        }
        
        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(102, 126, 234, 0.4);
        }
        
        .connect-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .connect-btn .loading-spinner {
            display: none;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        .connect-btn.loading .loading-spinner {
            display: inline-block;
        }
        
        /* é”™è¯¯è§£å†³æ–¹æ¡ˆé¢æ¿ */
        .solution-panel {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border: 1px solid #fbbf24;
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }
        
        .solution-panel.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }
        
        .solution-title {
            color: #92400e;
            font-weight: 700;
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        
        .solution-steps {
            list-style: none;
            padding: 0;
        }
        
        .solution-steps li {
            color: #92400e;
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }
        
        .solution-steps li:before {
            content: 'ğŸ“';
            position: absolute;
            left: 0;
        }
        
        /* å®æ—¶æ—¥å¿—é¢æ¿ */
        .log-panel {
            background: #1f2937;
            color: #d1d5db;
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
        
        .log-panel.show {
            display: block;
        }
        
        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
        }
        
        .log-entry.info { color: #60a5fa; }
        .log-entry.success { color: #34d399; }
        .log-entry.warning { color: #fbbf24; }
        .log-entry.error { color: #f87171; }
        
        /* åŠ¨ç”» */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* å·¥å…·æŒ‰é’® */
        .tool-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .tool-btn {
            padding: 8px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
        }
        
        .tool-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }
        
        .hidden { display: none; }
        
        /* ç®¡ç†é¢æ¿æ ·å¼ */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }
        
        .card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 12px 24px rgba(0,0,0,0.1);
            border: 1px solid #f0f0f0;
            transition: all 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
        }
        
        .card h3 {
            color: #2c3e50;
            margin-bottom: 24px;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
        }
        
        .card-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
        }
        
        .icon-mint { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .icon-burn { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
        .icon-permission { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
        .icon-query { background: linear-gradient(135deg, #c3cfe2 0%, #c3cfe2 100%); }
        .icon-settings { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #374151;
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 1em;
            transition: all 0.3s ease;
            background: #f9fafb;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 12px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
        }
        
        .btn-danger:hover {
            box-shadow: 0 6px 16px rgba(255, 107, 107, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }
        
        .status {
            padding: 16px;
            border-radius: 12px;
            margin: 16px 0;
            font-weight: 500;
            border-left: 4px solid;
        }
        
        .status.success {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border-color: #28a745;
        }
        
        .status.error {
            background: linear-gradient(135deg, #f8d7da 0%, #f1aeb5 100%);
            color: #721c24;
            border-color: #dc3545;
        }
        
        .status.info {
            background: linear-gradient(135deg, #d1ecf1 0%, #b8daff 100%);
            color: #0c5460;
            border-color: #17a2b8;
        }
        
        .status.warning {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            color: #856404;
            border-color: #ffc107;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 24px;
        }
        
        .info-item {
            background: linear-gradient(135deg, #f8f9fd 0%, #e9ecef 100%);
            padding: 24px;
            border-radius: 16px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        
        .info-item .value {
            font-size: 1.8em;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 8px;
        }
        
        .info-item .label {
            color: #6b7280;
            font-size: 0.9em;
            font-weight: 500;
        }
        
        .batch-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #e9ecef;
        }
        
        .batch-item {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            align-items: center;
        }
        
        .batch-item input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        
        .batch-controls {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }
        
        .btn-small {
            padding: 8px 16px;
            font-size: 0.9em;
            width: auto;
            margin: 0;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 16px;
            }
            
            .content {
                padding: 20px;
            }
            
            .connection-status {
                flex-direction: column;
                gap: 10px;
            }
            
            .status-indicator {
                min-width: auto;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸŒŸ FMHä»£å¸ç®¡ç†é¢æ¿ Pro</h1>
            <p>Intelligent Wallet Connection & Management Dashboard</p>
        </div>
        
        <div class="content">
            <!-- æ™ºèƒ½é’±åŒ…è¿æ¥é¢æ¿ -->
            <div class="wallet-connection-panel">
                <div class="connection-header">
                    <h2>ğŸ”— æ™ºèƒ½é’±åŒ…è¿æ¥ç³»ç»Ÿ</h2>
                    <p>å®æ—¶æ£€æµ‹ã€æ™ºèƒ½è¯Šæ–­ã€ä¸€é”®è§£å†³</p>
                </div>
                
                <!-- è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ -->
                <div class="connection-status">
                    <div class="status-indicator pending" id="browserStatus">
                        <div class="status-dot"></div>
                        <span>æµè§ˆå™¨æ£€æµ‹</span>
                    </div>
                    <div class="status-indicator pending" id="metamaskStatus">
                        <div class="status-dot"></div>
                        <span>MetaMaskæ£€æµ‹</span>
                    </div>
                    <div class="status-indicator pending" id="networkStatus">
                        <div class="status-dot"></div>
                        <span>ç½‘ç»œè¿æ¥</span>
                    </div>
                    <div class="status-indicator pending" id="contractStatus">
                        <div class="status-dot"></div>
                        <span>åˆçº¦éªŒè¯</span>
                    </div>
                </div>
                
                <!-- è¿æ¥æŒ‰é’® -->
                <div style="text-align: center;">
                    <button class="connect-btn" id="connectBtn" onclick="startSmartConnection()">
                        <div class="loading-spinner"></div>
                        <span>ğŸš€ æ™ºèƒ½è¿æ¥é’±åŒ…</span>
                    </button>
                </div>
                
                <!-- å·¥å…·æŒ‰é’® -->
                <div class="tool-buttons">
                    <button class="tool-btn" onclick="toggleDiagnostics()">ğŸ“Š è¯¦ç»†è¯Šæ–­</button>
                    <button class="tool-btn" onclick="toggleLogs()">ğŸ“ å®æ—¶æ—¥å¿—</button>
                    <button class="tool-btn" onclick="showWalletDetectionReport()">ğŸ” é’±åŒ…æ£€æµ‹æŠ¥å‘Š</button>
                    <button class="tool-btn" onclick="forceUseMetaMaskNow()">ğŸ¦Š å¼ºåˆ¶MetaMask</button>
                    <button class="tool-btn" onclick="resetConnection()">ğŸ”„ é‡ç½®è¿æ¥</button>
                    <button class="tool-btn" onclick="downloadReport()">ğŸ“‹ å¯¼å‡ºæŠ¥å‘Š</button>
                </div>
                
                <!-- è¯¦ç»†è¯Šæ–­é¢æ¿ -->
                <div class="diagnostic-panel" id="diagnosticPanel">
                    <h3 style="color: #374151; margin-bottom: 15px;">ğŸ” ç³»ç»Ÿè¯Šæ–­è¯¦æƒ…</h3>
                    <div id="diagnosticContent">
                        <!-- åŠ¨æ€ç”Ÿæˆè¯Šæ–­å†…å®¹ -->
                    </div>
                </div>
                
                <!-- è§£å†³æ–¹æ¡ˆé¢æ¿ -->
                <div class="solution-panel" id="solutionPanel">
                    <div class="solution-title" id="solutionTitle">ğŸ’¡ é—®é¢˜è§£å†³æ–¹æ¡ˆ</div>
                    <ul class="solution-steps" id="solutionSteps">
                        <!-- åŠ¨æ€ç”Ÿæˆè§£å†³æ­¥éª¤ -->
                    </ul>
                </div>
                
                <!-- é’±åŒ…æ£€æµ‹æŠ¥å‘Šé¢æ¿ -->
                <div class="diagnostic-panel" id="walletDetectionPanel">
                    <h3 style="color: #374151; margin-bottom: 15px;">ğŸ” é’±åŒ…æ’ä»¶æ£€æµ‹è¯¦ç»†æŠ¥å‘Š</h3>
                    <div id="walletDetectionContent">
                        <!-- åŠ¨æ€ç”Ÿæˆé’±åŒ…æ£€æµ‹å†…å®¹ -->
                    </div>
                </div>
                
                <!-- å®æ—¶æ—¥å¿—é¢æ¿ -->
                <div class="log-panel" id="logPanel">
                    <div style="color: #fbbf24; margin-bottom: 10px; font-weight: bold;">ğŸ” å®æ—¶è¿æ¥æ—¥å¿—</div>
                    <div id="logContent">
                        <!-- åŠ¨æ€ç”Ÿæˆæ—¥å¿—å†…å®¹ -->
                    </div>
                </div>
            </div>
            
            <!-- ç®¡ç†åŠŸèƒ½é¢æ¿ï¼ˆè¿æ¥æˆåŠŸåæ˜¾ç¤ºï¼‰-->
            <div id="mainPanel" class="hidden">
                <!-- è¿æ¥æˆåŠŸçŠ¶æ€æ˜¾ç¤º -->
                <div style="text-align: center; padding: 30px; background: linear-gradient(135deg, #d4f1d4 0%, #a7f3a7 100%); border-radius: 20px; margin-bottom: 30px;">
                    <h2 style="color: #15803d; margin-bottom: 15px;">âœ… é’±åŒ…è¿æ¥æˆåŠŸï¼</h2>
                    <p style="color: #166534; font-size: 1em;" id="connectedWalletInfo">æ­£åœ¨åŠ è½½é’±åŒ…ä¿¡æ¯...</p>
                </div>

                <!-- åˆçº¦çŠ¶æ€æ¦‚è§ˆ -->
                <div class="card">
                    <h3>
                        <span class="card-icon icon-query">ğŸ“Š</span>
                        åˆçº¦çŠ¶æ€æ¦‚è§ˆ
                    </h3>
                    <button class="btn btn-secondary" onclick="refreshContractInfo()">ğŸ”„ åˆ·æ–°æ‰€æœ‰ä¿¡æ¯</button>
                    <div id="contractInfo"></div>
                </div>
                
                <div class="grid">
                    <!-- é“¸å¸é¢æ¿ -->
                    <div class="card">
                        <h3>
                            <span class="card-icon icon-mint">ğŸ­</span>
                            é“¸é€ ä»£å¸
                        </h3>
                        <div class="form-group">
                            <label>æ¥æ”¶åœ°å€:</label>
                            <input type="text" id="mintToAddress" placeholder="è¾“å…¥æ¥æ”¶ä»£å¸çš„é’±åŒ…åœ°å€ (0x...)">
                        </div>
                        <div class="form-group">
                            <label>é“¸é€ æ•°é‡:</label>
                            <input type="number" id="mintAmount" placeholder="è¾“å…¥é“¸é€ æ•°é‡" min="0" step="0.001">
                        </div>
                        <button class="btn" onclick="mintTokens()">ğŸ­ æ‰§è¡Œé“¸é€ </button>
                        <div id="mintStatus"></div>
                    </div>
                    
                    <!-- å•ç‹¬é”€æ¯é¢æ¿ -->
                    <div class="card">
                        <h3>
                            <span class="card-icon icon-burn">ğŸ”¥</span>
                            é”€æ¯ä»£å¸
                        </h3>
                        <div class="form-group">
                            <label>é”€æ¯æ–¹å¼:</label>
                            <select id="burnType" onchange="toggleBurnInputs()">
                                <option value="burn">é”€æ¯è‡ªå·±çš„ä»£å¸</option>
                                <option value="burnFrom">é”€æ¯ä»–äººçš„ä»£å¸</option>
                            </select>
                        </div>
                        <div class="form-group" id="burnFromGroup" style="display: none;">
                            <label>ç›®æ ‡åœ°å€:</label>
                            <input type="text" id="burnFromAddress" placeholder="è¾“å…¥è¦é”€æ¯ä»£å¸çš„åœ°å€">
                        </div>
                        <div class="form-group">
                            <label>é”€æ¯æ•°é‡:</label>
                            <input type="number" id="burnAmount" placeholder="è¾“å…¥é”€æ¯æ•°é‡" min="0" step="0.001">
                        </div>
                        <button class="btn btn-danger" onclick="burnTokens()">ğŸ”¥ æ‰§è¡Œé”€æ¯</button>
                        <div id="burnStatus"></div>
                    </div>
                    
                    <!-- æ‰¹é‡é”€æ¯é¢æ¿ -->
                    <div class="card">
                        <h3>
                            <span class="card-icon icon-burn">ğŸ”¥</span>
                            æ‰¹é‡é”€æ¯ä»£å¸
                        </h3>
                        <div class="batch-section">
                            <div id="batchBurnList">
                                <div class="batch-item">
                                    <input type="text" placeholder="åœ°å€ (0x...)" class="batch-address">
                                    <input type="number" placeholder="æ•°é‡" class="batch-amount" min="0" step="0.001">
                                    <button class="btn btn-danger btn-small" onclick="removeBatchItem(this)">åˆ é™¤</button>
                                </div>
                            </div>
                            <div class="batch-controls">
                                <button class="btn btn-secondary btn-small" onclick="addBatchItem()">â• æ·»åŠ é¡¹ç›®</button>
                                <button class="btn btn-danger btn-small" onclick="executeBatchBurn()">ğŸ”¥ æ‰¹é‡é”€æ¯</button>
                            </div>
                        </div>
                        <div id="batchBurnStatus"></div>
                    </div>
                    
                    <!-- æƒé™ç®¡ç†é¢æ¿ -->
                    <div class="card">
                        <h3>
                            <span class="card-icon icon-permission">ğŸ‘¥</span>
                            é“¸å¸æƒé™ç®¡ç†
                        </h3>
                        <div class="form-group">
                            <label>æ·»åŠ é“¸å¸è€…:</label>
                            <input type="text" id="newMinterAddress" placeholder="è¾“å…¥è¦æˆæƒçš„åœ°å€">
                            <button class="btn" onclick="addMinter()">â• æ·»åŠ é“¸å¸è€…</button>
                        </div>
                        
                        <div class="form-group">
                            <label>ç§»é™¤é“¸å¸è€…:</label>
                            <input type="text" id="removeMinterAddress" placeholder="è¾“å…¥è¦ç§»é™¤çš„åœ°å€">
                            <button class="btn btn-danger" onclick="removeMinter()">â– ç§»é™¤é“¸å¸è€…</button>
                        </div>
                        
                        <div class="form-group">
                            <label>æ£€æŸ¥æƒé™:</label>
                            <input type="text" id="checkMinterAddress" placeholder="è¾“å…¥è¦æ£€æŸ¥çš„åœ°å€">
                            <button class="btn btn-secondary" onclick="checkMinterPermission()">ğŸ” æ£€æŸ¥æƒé™</button>
                        </div>
                        
                        <div id="minterStatus"></div>
                    </div>
                    
                    <!-- ä»£å¸æŸ¥è¯¢é¢æ¿ -->
                    <div class="card">
                        <h3>
                            <span class="card-icon icon-query">ğŸ”</span>
                            ä»£å¸æŸ¥è¯¢
                        </h3>
                        <div class="form-group">
                            <label>æŸ¥è¯¢åœ°å€ä½™é¢:</label>
                            <input type="text" id="queryAddress" placeholder="è¾“å…¥è¦æŸ¥è¯¢çš„é’±åŒ…åœ°å€">
                            <button class="btn btn-secondary" onclick="queryBalance()">ğŸ’° æŸ¥è¯¢ä½™é¢</button>
                        </div>
                        
                        <div class="form-group">
                            <label>æŸ¥è¯¢é”€æ¯ç‡:</label>
                            <button class="btn btn-secondary" onclick="getBurnRate()">ğŸ“ˆ è·å–é”€æ¯ç‡</button>
                        </div>
                        
                        <div id="queryResults"></div>
                    </div>
                    
                    <!-- ç³»ç»Ÿè®¾ç½®é¢æ¿ -->
                    <div class="card">
                        <h3>
                            <span class="card-icon icon-settings">âš™ï¸</span>
                            ç³»ç»Ÿè®¾ç½®
                        </h3>
                        <div class="form-group">
                            <label>è®¾ç½®æ¸¸æˆåˆçº¦åœ°å€:</label>
                            <input type="text" id="gameContractAddress" placeholder="è¾“å…¥æ¸¸æˆåˆçº¦åœ°å€">
                            <button class="btn" onclick="setGameContract()">âš™ï¸ æ›´æ–°æ¸¸æˆåˆçº¦</button>
                        </div>
                        
                        <div class="form-group">
                            <label>å½“å‰æ¸¸æˆåˆçº¦:</label>
                            <button class="btn btn-secondary" onclick="getCurrentGameContract()">ğŸ® æŸ¥è¯¢å½“å‰æ¸¸æˆåˆçº¦</button>
                        </div>
                        
                        <div id="settingsStatus"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ™ºèƒ½é’±åŒ…è¿æ¥ç³»ç»Ÿ
        class SmartWalletConnector {
            constructor() {
                this.diagnostics = {
                    browser: { status: 'pending', message: 'ç­‰å¾…æ£€æµ‹...' },
                    metamask: { status: 'pending', message: 'ç­‰å¾…æ£€æµ‹...' },
                    network: { status: 'pending', message: 'ç­‰å¾…æ£€æµ‹...' },
                    contract: { status: 'pending', message: 'ç­‰å¾…æ£€æµ‹...' }
                };
                this.logs = [];
                this.contract = null;
                this.provider = null;
                this.signer = null;
            }
            
            // æ·»åŠ æ—¥å¿—
            addLog(type, message) {
                const timestamp = new Date().toLocaleTimeString();
                this.logs.push({ type, message, timestamp });
                this.updateLogDisplay();
                console.log(`[${timestamp}] ${type.toUpperCase()}: ${message}`);
            }
            
            // æ›´æ–°æ—¥å¿—æ˜¾ç¤º
            updateLogDisplay() {
                const logContent = document.getElementById('logContent');
                if (logContent && this.logs.length > 0) {
                    const recentLogs = this.logs.slice(-20); // åªæ˜¾ç¤ºæœ€è¿‘20æ¡
                    logContent.innerHTML = recentLogs.map(log => 
                        `<div class="log-entry ${log.type}">[${log.timestamp}] ${log.message}</div>`
                    ).join('');
                    logContent.scrollTop = logContent.scrollHeight;
                }
            }
            
            // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
            updateStatus(type, status, message = '') {
                this.diagnostics[type] = { status, message };
                const element = document.getElementById(`${type}Status`);
                if (element) {
                    element.className = `status-indicator ${status}`;
                    const dot = element.querySelector('.status-dot');
                    if (dot) {
                        dot.className = status === 'checking' ? 'status-dot animate' : 'status-dot';
                    }
                }
                this.updateDiagnosticPanel();
            }
            
            // æ›´æ–°è¯Šæ–­é¢æ¿
            updateDiagnosticPanel() {
                const content = document.getElementById('diagnosticContent');
                if (!content) return;
                
                const diagnosticItems = Object.entries(this.diagnostics).map(([key, data]) => {
                    const icon = data.status === 'success' ? 'success' : 
                                data.status === 'error' ? 'error' : 'loading';
                    const label = {
                        browser: 'æµè§ˆå™¨ç¯å¢ƒ',
                        metamask: 'MetaMask çŠ¶æ€',
                        network: 'ç½‘ç»œè¿æ¥',
                        contract: 'åˆçº¦éªŒè¯'
                    }[key];
                    
                    return `
                        <div class="diagnostic-item">
                            <div class="diagnostic-label">${label}</div>
                            <div class="diagnostic-value">
                                <div class="diagnostic-icon ${icon}"></div>
                                <span>${data.message}</span>
                            </div>
                        </div>
                    `;
                }).join('');
                
                content.innerHTML = diagnosticItems;
            }
            
            // æ˜¾ç¤ºè§£å†³æ–¹æ¡ˆ
            showSolution(title, steps) {
                const panel = document.getElementById('solutionPanel');
                const titleEl = document.getElementById('solutionTitle');
                const stepsEl = document.getElementById('solutionSteps');
                
                if (panel && titleEl && stepsEl) {
                    titleEl.textContent = title;
                    stepsEl.innerHTML = steps.map(step => `<li>${step}</li>`).join('');
                    panel.classList.add('show');
                }
            }
            
            // éšè—è§£å†³æ–¹æ¡ˆ
            hideSolution() {
                const panel = document.getElementById('solutionPanel');
                if (panel) {
                    panel.classList.remove('show');
                }
            }
            
            // æ£€æµ‹æµè§ˆå™¨ç¯å¢ƒ
            async checkBrowser() {
                this.addLog('info', 'å¼€å§‹æ£€æµ‹æµè§ˆå™¨ç¯å¢ƒ...');
                this.updateStatus('browser', 'checking', 'æ£€æµ‹ä¸­...');
                
                await this.delay(1000); // æ¨¡æ‹Ÿæ£€æµ‹æ—¶é—´
                
                const userAgent = navigator.userAgent.toLowerCase();
                let browserName = 'Unknown';
                let isSupported = false;
                
                if (userAgent.includes('chrome') && !userAgent.includes('edge')) {
                    browserName = 'Chrome';
                    isSupported = true;
                } else if (userAgent.includes('firefox')) {
                    browserName = 'Firefox';
                    isSupported = true;
                } else if (userAgent.includes('edge')) {
                    browserName = 'Edge';
                    isSupported = true;
                } else if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
                    browserName = 'Safari';
                    isSupported = false;
                }
                
                if (isSupported) {
                    this.updateStatus('browser', 'success', `${browserName} âœ…`);
                    this.addLog('success', `æµè§ˆå™¨æ£€æµ‹é€šè¿‡: ${browserName}`);
                    return true;
                } else {
                    this.updateStatus('browser', 'error', `${browserName} âŒ`);
                    this.addLog('error', `ä¸æ”¯æŒçš„æµè§ˆå™¨: ${browserName}`);
                    this.showSolution('ğŸŒ æµè§ˆå™¨å…¼å®¹æ€§é—®é¢˜', [
                        'è¯·ä½¿ç”¨ Chromeã€Firefox æˆ– Edge æµè§ˆå™¨',
                        'ç¡®ä¿æµè§ˆå™¨ç‰ˆæœ¬æ˜¯æœ€æ–°çš„',
                        'Safari æµè§ˆå™¨æš‚ä¸æ”¯æŒ MetaMask æ‰©å±•',
                        'ç§»åŠ¨ç«¯è¯·ä½¿ç”¨å†…ç½® DApp æµè§ˆå™¨'
                    ]);
                    return false;
                }
            }
            
            // æ£€æµ‹MetaMaskï¼ˆå¢å¼ºç‰ˆæœ¬ï¼Œä¼˜å…ˆé€‰æ‹©MetaMaskï¼‰
            async checkMetaMask() {
                this.addLog('info', 'å¼€å§‹å¢å¼ºMetaMaskæ£€æµ‹...');
                this.updateStatus('metamask', 'checking', 'æ£€æµ‹ä¸­...');
                
                await this.delay(800);
                
                // é¦–å…ˆå°è¯•å¼ºåˆ¶ä½¿ç”¨MetaMask
                const metamaskProvider = await this.forceSelectMetaMask();
                
                if (metamaskProvider) {
                    this.addLog('success', 'âœ… æˆåŠŸé€‰æ‹©MetaMaskä½œä¸ºä¸»provider');
                    // ä¸´æ—¶æ›¿æ¢window.ethereumç¡®ä¿ä½¿ç”¨MetaMask
                    window.ethereum = metamaskProvider;
                } else {
                    this.addLog('warning', 'âš ï¸ æœªæ‰¾åˆ°MetaMaskï¼Œä½¿ç”¨é»˜è®¤æ£€æµ‹');
                }
                
                // ä½¿ç”¨å¢å¼ºæ£€æµ‹ç³»ç»Ÿ
                const detectionResult = await this.enhancedWalletDetection();
                
                if (!detectionResult.metamask.detected) {
                    this.updateStatus('metamask', 'error', 'æœªå®‰è£… âŒ');
                    this.addLog('error', 'MetaMask æœªå®‰è£…');
                    this.showSolution('ğŸ¦Š MetaMask æœªå®‰è£…', [
                        'è®¿é—® https://metamask.io ä¸‹è½½ MetaMask',
                        'å®‰è£…æµè§ˆå™¨æ‰©å±•ç¨‹åº',
                        'é‡å¯æµè§ˆå™¨ååˆ·æ–°æ­¤é¡µé¢',
                        'ç¡®ä¿æ‰©å±•ç¨‹åºå·²å¯ç”¨'
                    ]);
                    return false;
                }
                
                // æ£€æµ‹å¤šé’±åŒ…å†²çªå¹¶æä¾›è¯¦ç»†ä¿¡æ¯
                if (detectionResult.web3.details.total > 1) {
                    this.addLog('warning', `æ£€æµ‹åˆ°${detectionResult.web3.details.total}ä¸ªé’±åŒ…: ${detectionResult.web3.details.providers.join(', ')}`);
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰å†²çª
                    if (detectionResult.metamask.details.conflicts && detectionResult.metamask.details.conflicts.length > 0) {
                        this.addLog('warning', `å‘ç°é’±åŒ…å†²çª: ${detectionResult.metamask.details.conflicts.join(', ')}`);
                        this.showSolution('âš ï¸ å¤šé’±åŒ…å†²çª', [
                            'å»ºè®®ç¦ç”¨å…¶ä»–é’±åŒ…æ‰©å±•ä»¥é¿å…å†²çª',
                            'ä¿æŒ MetaMask å¯ç”¨',
                            'é‡å¯æµè§ˆå™¨åé‡è¯•',
                            'å¦‚æœé—®é¢˜æŒç»­ï¼Œå°è¯•ä½¿ç”¨æ— ç—•æ¨¡å¼'
                        ]);
                    }
                }
                
                // ç­‰å¾… MetaMask å®Œå…¨åŠ è½½
                let attempts = 0;
                while (typeof window.ethereum?.request !== 'function' && attempts < 10) {
                    await this.delay(500);
                    attempts++;
                    this.addLog('info', `ç­‰å¾… MetaMask åˆå§‹åŒ–... (${attempts}/10)`);
                }
                
                if (typeof window.ethereum?.request !== 'function') {
                    this.updateStatus('metamask', 'error', 'åŠ è½½å¤±è´¥ âŒ');
                    this.addLog('error', 'MetaMask åˆå§‹åŒ–å¤±è´¥');
                    this.showSolution('ğŸ”„ MetaMask åŠ è½½é—®é¢˜', [
                        'ç¦ç”¨å…¶ä»–é’±åŒ…æ‰©å±•ç¨‹åº',
                        'åˆ·æ–°é¡µé¢é‡è¯•',
                        'é‡å¯æµè§ˆå™¨',
                        'æ£€æŸ¥ MetaMask æ‰©å±•æ˜¯å¦æ­£å¸¸å·¥ä½œ'
                    ]);
                    return false;
                }
                
                // è®°å½•æ£€æµ‹è¯¦æƒ…
                const details = detectionResult.metamask.details;
                this.addLog('info', `MetaMaskç‰ˆæœ¬: ${details.version}`);
                this.addLog('info', `å°±ç»ªçŠ¶æ€: ${details.ready ? 'æ˜¯' : 'å¦'}`);
                
                this.updateStatus('metamask', 'success', `å·²å®‰è£… âœ… v${details.version}`);
                this.addLog('success', 'MetaMask å¢å¼ºæ£€æµ‹é€šè¿‡');
                return true;
            }
            
            // å¢å¼ºé’±åŒ…æ£€æµ‹ç³»ç»Ÿ
            async enhancedWalletDetection() {
                const results = {
                    browser: { detected: false, details: {} },
                    metamask: { detected: false, details: {} },
                    phantom: { detected: false, details: {} },
                    coinbase: { detected: false, details: {} },
                    okx: { detected: false, details: {} },
                    web3: { detected: false, details: {} }
                };
                
                // æµè§ˆå™¨æ£€æµ‹
                await this.detectBrowserEnhanced(results);
                
                // ç­‰å¾…é¡µé¢å®Œå…¨åŠ è½½
                await this.delay(1000);
                
                // MetaMask æ£€æµ‹
                await this.detectMetaMaskEnhanced(results);
                
                // Phantom æ£€æµ‹
                await this.detectPhantomEnhanced(results);
                
                // Coinbase æ£€æµ‹
                await this.detectCoinbaseEnhanced(results);
                
                // OKX æ£€æµ‹
                await this.detectOKXEnhanced(results);
                
                // é€šç”¨ Web3 æ£€æµ‹
                await this.detectWeb3Enhanced(results);
                
                return results;
            }
            
            async detectBrowserEnhanced(results) {
                const userAgent = navigator.userAgent.toLowerCase();
                let browserInfo = {
                    name: 'Unknown',
                    version: 'Unknown',
                    compatible: false,
                    engine: 'Unknown',
                    mobile: /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent)
                };
                
                // Chrome æ£€æµ‹
                if (userAgent.includes('chrome') && !userAgent.includes('edge') && !userAgent.includes('opr')) {
                    browserInfo.name = 'Chrome';
                    browserInfo.compatible = true;
                    browserInfo.engine = 'Chromium';
                    const match = userAgent.match(/chrome\/([0-9\.]+)/);
                    if (match) browserInfo.version = match[1];
                }
                // Edge æ£€æµ‹
                else if (userAgent.includes('edge')) {
                    browserInfo.name = 'Edge';
                    browserInfo.compatible = true;
                    browserInfo.engine = 'Chromium';
                    const match = userAgent.match(/edge\/([0-9\.]+)/);
                    if (match) browserInfo.version = match[1];
                }
                // Firefox æ£€æµ‹
                else if (userAgent.includes('firefox')) {
                    browserInfo.name = 'Firefox';
                    browserInfo.compatible = true;
                    browserInfo.engine = 'Gecko';
                    const match = userAgent.match(/firefox\/([0-9\.]+)/);
                    if (match) browserInfo.version = match[1];
                }
                // Safari æ£€æµ‹
                else if (userAgent.includes('safari') && !userAgent.includes('chrome')) {
                    browserInfo.name = 'Safari';
                    browserInfo.compatible = false;
                    browserInfo.engine = 'WebKit';
                    const match = userAgent.match(/version\/([0-9\.]+)/);
                    if (match) browserInfo.version = match[1];
                }
                // Opera æ£€æµ‹
                else if (userAgent.includes('opr') || userAgent.includes('opera')) {
                    browserInfo.name = 'Opera';
                    browserInfo.compatible = true;
                    browserInfo.engine = 'Chromium';
                }
                
                results.browser = {
                    detected: true,
                    details: browserInfo
                };
            }
            
            async detectMetaMaskEnhanced(results) {
                const details = {
                    installed: false,
                    version: 'Unknown',
                    provider: null,
                    conflicts: [],
                    ready: false
                };
                
                // åŸºç¡€æ£€æµ‹
                if (typeof window.ethereum !== 'undefined') {
                    // æ£€æµ‹æ˜¯å¦ä¸º MetaMask
                    if (window.ethereum.isMetaMask) {
                        details.installed = true;
                        details.provider = window.ethereum;
                        details.ready = typeof window.ethereum.request === 'function';
                        
                        // ç‰ˆæœ¬æ£€æµ‹
                        try {
                            if (window.ethereum._metamask && window.ethereum._metamask.version) {
                                details.version = window.ethereum._metamask.version;
                            }
                        } catch (e) {
                            console.log('æ— æ³•è·å–MetaMaskç‰ˆæœ¬');
                        }
                        
                        // å¤šé’±åŒ…å†²çªæ£€æµ‹
                        if (window.ethereum.providers && window.ethereum.providers.length > 1) {
                            details.conflicts = window.ethereum.providers
                                .filter(p => !p.isMetaMask)
                                .map(p => this.getProviderName(p));
                        }
                    }
                    // æ£€æµ‹æ˜¯å¦åœ¨ MetaMask å†…ç½®æµè§ˆå™¨ä¸­
                    else if (window.ethereum.isMetaMask === undefined && window.web3) {
                        details.installed = true;
                        details.provider = window.ethereum;
                        details.ready = true;
                        details.version = 'å†…ç½®æµè§ˆå™¨';
                    }
                }
                
                // é¢å¤–çš„ MetaMask æ£€æµ‹æ–¹æ³•
                if (!details.installed) {
                    // æ£€æµ‹æ‰©å±•æ³¨å…¥
                    if (window.web3 && window.web3.currentProvider && window.web3.currentProvider.isMetaMask) {
                        details.installed = true;
                        details.provider = window.web3.currentProvider;
                        details.version = 'Legacy Web3';
                    }
                }
                
                results.metamask = {
                    detected: details.installed,
                    details
                };
            }
            
            async detectPhantomEnhanced(results) {
                const details = {
                    installed: false,
                    version: 'Unknown',
                    provider: null,
                    ethereum: false,
                    solana: false
                };
                
                // Phantom ç‰¹å®šæ£€æµ‹
                if (typeof window.phantom !== 'undefined') {
                    details.installed = true;
                    
                    if (window.phantom.ethereum) {
                        details.ethereum = true;
                        details.provider = window.phantom.ethereum;
                    }
                    
                    if (window.phantom.solana) {
                        details.solana = true;
                    }
                }
                
                // é€šè¿‡ ethereum provider æ£€æµ‹
                if (!details.installed && typeof window.ethereum !== 'undefined') {
                    if (window.ethereum.isPhantom) {
                        details.installed = true;
                        details.ethereum = true;
                        details.provider = window.ethereum;
                    }
                }
                
                results.phantom = {
                    detected: details.installed,
                    details
                };
            }
            
            async detectCoinbaseEnhanced(results) {
                const details = {
                    installed: false,
                    version: 'Unknown',
                    provider: null,
                    mobile: false
                };
                
                // Coinbase Wallet æ£€æµ‹
                if (typeof window.ethereum !== 'undefined') {
                    if (window.ethereum.isCoinbaseWallet || window.ethereum.selectedProvider?.isCoinbaseWallet) {
                        details.installed = true;
                        details.provider = window.ethereum;
                    }
                }
                
                // ç§»åŠ¨ç«¯ Coinbase æ£€æµ‹
                if (typeof window.coinbaseWalletExtension !== 'undefined') {
                    details.installed = true;
                    details.mobile = true;
                }
                
                results.coinbase = {
                    detected: details.installed,
                    details
                };
            }
            
            async detectOKXEnhanced(results) {
                const details = {
                    installed: false,
                    version: 'Unknown',
                    provider: null
                };
                
                // OKX Wallet æ£€æµ‹
                if (typeof window.okxwallet !== 'undefined') {
                    details.installed = true;
                    details.provider = window.okxwallet;
                }
                
                // é€šè¿‡ ethereum provider æ£€æµ‹
                if (!details.installed && typeof window.ethereum !== 'undefined') {
                    if (window.ethereum.isOkxWallet || window.ethereum.isOKExWallet) {
                        details.installed = true;
                        details.provider = window.ethereum;
                    }
                }
                
                results.okx = {
                    detected: details.installed,
                    details
                };
            }
            
            async detectWeb3Enhanced(results) {
                const details = {
                    ethereum: typeof window.ethereum !== 'undefined',
                    web3: typeof window.web3 !== 'undefined',
                    providers: [],
                    total: 0
                };
                
                // ç»Ÿè®¡æ‰€æœ‰æä¾›è€…
                if (window.ethereum) {
                    if (window.ethereum.providers) {
                        details.providers = window.ethereum.providers.map(p => this.getProviderName(p));
                        details.total = window.ethereum.providers.length;
                    } else {
                        details.providers.push(this.getProviderName(window.ethereum));
                        details.total = 1;
                    }
                }
                
                results.web3 = {
                    detected: details.ethereum || details.web3,
                    details
                };
            }
            
            getProviderName(provider) {
                if (provider.isMetaMask) return 'MetaMask';
                if (provider.isPhantom) return 'Phantom';
                if (provider.isCoinbaseWallet) return 'Coinbase';
                if (provider.isOkxWallet || provider.isOKExWallet) return 'OKX';
                if (provider.isBraveWallet) return 'Brave';
                return 'Unknown Provider';
            }
            
            // å¼ºåˆ¶é€‰æ‹©MetaMaskä½œä¸ºä¸»provider
            async forceSelectMetaMask() {
                this.addLog('info', 'ğŸ” æœç´¢MetaMask provider...');
                
                if (typeof window.ethereum === 'undefined') {
                    this.addLog('error', 'âŒ window.ethereumä¸å­˜åœ¨');
                    return null;
                }
                
                // æ£€æŸ¥å½“å‰window.ethereumæ˜¯å¦å·²ç»æ˜¯MetaMask
                if (window.ethereum.isMetaMask && !window.ethereum.isPhantom) {
                    this.addLog('success', 'âœ… window.ethereumå·²ç»æ˜¯MetaMask');
                    return window.ethereum;
                }
                
                // æ£€æŸ¥å¤šproviderç¯å¢ƒ
                if (window.ethereum.providers && Array.isArray(window.ethereum.providers)) {
                    this.addLog('info', `ğŸ” æ£€æŸ¥${window.ethereum.providers.length}ä¸ªprovider...`);
                    
                    for (let i = 0; i < window.ethereum.providers.length; i++) {
                        const provider = window.ethereum.providers[i];
                        const providerName = this.getProviderName(provider);
                        this.addLog('info', `  Provider ${i+1}: ${providerName}`);
                        
                        if (provider.isMetaMask && !provider.isPhantom) {
                            this.addLog('success', `âœ… æ‰¾åˆ°MetaMask provider (ä½ç½®: ${i+1})`);
                            return provider;
                        }
                    }
                    
                    this.addLog('warning', 'âš ï¸ åœ¨å¤šproviderç¯å¢ƒä¸­æœªæ‰¾åˆ°çº¯MetaMask');
                } else {
                    // å•providerç¯å¢ƒ
                    if (window.ethereum.isPhantom && !window.ethereum.isMetaMask) {
                        this.addLog('warning', 'âš ï¸ window.ethereumè¢«Phantomæ§åˆ¶');
                        
                        // å°è¯•æŸ¥æ‰¾åŸå§‹çš„MetaMask
                        if (window.ethereum._metamask) {
                            this.addLog('info', 'ğŸ” å°è¯•è®¿é—®åŸå§‹MetaMask...');
                            return window.ethereum._metamask;
                        }
                    }
                }
                
                // æœ€åçš„å°è¯•ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„åå¥½è®¾ç½®
                const preferredWallet = localStorage.getItem('preferredWallet');
                if (preferredWallet === 'metamask') {
                    this.addLog('info', 'ğŸ’¾ æ£€æµ‹åˆ°MetaMaskåå¥½è®¾ç½®');
                    // å³ä½¿å¯èƒ½ä¸å®Œç¾ï¼Œä¹Ÿä¼˜å…ˆä½¿ç”¨window.ethereum
                    return window.ethereum;
                }
                
                this.addLog('warning', 'âš ï¸ æœªæ‰¾åˆ°ç†æƒ³çš„MetaMask providerï¼Œä½¿ç”¨é»˜è®¤');
                return null;
            }
            
            // ç¦ç”¨å…¶ä»–é’±åŒ…çš„è‡ªåŠ¨è¿æ¥
            disableOtherWallets() {
                this.addLog('info', 'ğŸ”‡ ç¦ç”¨å…¶ä»–é’±åŒ…çš„è‡ªåŠ¨è¡Œä¸º...');
                
                try {
                    // ç¦ç”¨Phantomè‡ªåŠ¨è¿æ¥
                    if (window.phantom) {
                        if (typeof window.phantom.connect === 'function') {
                            const originalConnect = window.phantom.connect;
                            window.phantom.connect = function() {
                                console.log('Phantom connect blocked by FMH system');
                                return Promise.resolve([]);
                            };
                            this.addLog('success', 'âœ… å·²é˜»æ­¢Phantomè‡ªåŠ¨è¿æ¥');
                        }
                    }
                    
                    // ç¦ç”¨å…¶ä»–å¯èƒ½çš„è‡ªåŠ¨è¿æ¥
                    if (window.ethereum && window.ethereum.isPhantom) {
                        // å¦‚æœwindow.ethereumè¢«Phantomæ§åˆ¶ï¼Œå°è¯•é˜»æ­¢è‡ªåŠ¨è¡Œä¸º
                        if (window.ethereum.isConnected && window.ethereum.isConnected()) {
                            this.addLog('warning', 'âš ï¸ Phantomå·²è¿æ¥ï¼Œå°è¯•ä½¿ç”¨MetaMaskä¼˜å…ˆ');
                        }
                    }
                    
                } catch (error) {
                    this.addLog('warning', `âš ï¸ ç¦ç”¨å…¶ä»–é’±åŒ…æ—¶å‡ºé”™: ${error.message}`);
                }
            }
            
            // æ£€æµ‹ç½‘ç»œè¿æ¥
            async checkNetwork() {
                this.addLog('info', 'å¼€å§‹æ£€æµ‹ç½‘ç»œè¿æ¥...');
                this.updateStatus('network', 'checking', 'è¿æ¥ä¸­...');
                
                try {
                    // è¯·æ±‚è¿æ¥è´¦æˆ·
                    this.addLog('info', 'è¯·æ±‚è¿æ¥ MetaMask è´¦æˆ·...');
                    const accounts = await window.ethereum.request({ 
                        method: 'eth_requestAccounts' 
                    });
                    
                    if (accounts.length === 0) {
                        throw new Error('æ²¡æœ‰å¯ç”¨è´¦æˆ·');
                    }
                    
                    this.addLog('success', `è´¦æˆ·è¿æ¥æˆåŠŸ: ${accounts[0]}`);
                    
                    // æ£€æŸ¥å½“å‰ç½‘ç»œï¼ˆå¢å¼ºè°ƒè¯•ï¼‰
                    const chainId = await window.ethereum.request({ 
                        method: 'eth_chainId' 
                    });
                    
                    const chainIdDecimal = parseInt(chainId, 16);
                    this.addLog('info', `å½“å‰ç½‘ç»œ Chain ID: ${chainId} (åè¿›åˆ¶: ${chainIdDecimal})`);
                    
                    const targetChainId = '0x279F'; // Monad Testnet
                    const targetChainIdDecimal = 10143;
                    
                    // è¯¦ç»†çš„ç½‘ç»œåŒ¹é…æ£€æŸ¥ (æ”¯æŒå¤§å°å†™å¿½ç•¥)
                    this.addLog('info', `ç›®æ ‡ç½‘ç»œ: ${targetChainId} (åè¿›åˆ¶: ${targetChainIdDecimal})`);
                    
                    const chainIdMatch = {
                        exact: chainId === targetChainId,
                        caseInsensitive: chainId.toLowerCase() === targetChainId.toLowerCase(),
                        decimal: parseInt(chainId, 16) === targetChainIdDecimal
                    };
                    
                    this.addLog('info', `ä¸¥æ ¼åŒ¹é…: ${chainIdMatch.exact ? 'âœ…' : 'âŒ'}`);
                    this.addLog('info', `å¿½ç•¥å¤§å°å†™: ${chainIdMatch.caseInsensitive ? 'âœ…' : 'âŒ'}`);
                    this.addLog('info', `åè¿›åˆ¶åŒ¹é…: ${chainIdMatch.decimal ? 'âœ…' : 'âŒ'}`);
                    
                    // ä½¿ç”¨æ›´å®½æ¾çš„åŒ¹é…æ¡ä»¶
                    const networkMatched = chainIdMatch.caseInsensitive || chainIdMatch.decimal;
                    
                    if (!networkMatched) {
                        this.addLog('warning', `éœ€è¦åˆ‡æ¢åˆ° Monad æµ‹è¯•ç½‘ç»œ...`);
                        this.addLog('warning', `å½“å‰: ${chainId} (${chainIdDecimal}), ç›®æ ‡: ${targetChainId} (${targetChainIdDecimal})`);
                        
                        try {
                            this.addLog('info', 'å°è¯•åˆ‡æ¢ç½‘ç»œ...');
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: targetChainId }],
                            });
                            this.addLog('success', 'ç½‘ç»œåˆ‡æ¢æˆåŠŸ');
                        } catch (switchError) {
                            this.addLog('warning', `åˆ‡æ¢å¤±è´¥: ${switchError.message} (ä»£ç : ${switchError.code})`);
                            
                            if (switchError.code === 4902) {
                                this.addLog('info', 'ç½‘ç»œä¸å­˜åœ¨ï¼Œæ­£åœ¨æ·»åŠ  Monad æµ‹è¯•ç½‘ç»œ...');
                                try {
                                    await window.ethereum.request({
                                        method: 'wallet_addEthereumChain',
                                        params: [{
                                            chainId: targetChainId,
                                            chainName: 'Monad Testnet',
                                            nativeCurrency: {
                                                name: 'MON',
                                                symbol: 'MON',
                                                decimals: 18
                                            },
                                            rpcUrls: [
                                                'https://testnet-rpc.monad.xyz',
                                                'https://monad-testnet-rpc.publicnode.com'
                                            ],
                                            blockExplorerUrls: ['https://testnet-explorer.monad.xyz']
                                        }]
                                    });
                                    this.addLog('success', 'Monad æµ‹è¯•ç½‘æ·»åŠ æˆåŠŸ');
                                    
                                    // æ·»åŠ åå†æ¬¡å°è¯•åˆ‡æ¢
                                    this.addLog('info', 'å†æ¬¡å°è¯•åˆ‡æ¢ç½‘ç»œ...');
                                    await window.ethereum.request({
                                        method: 'wallet_switchEthereumChain',
                                        params: [{ chainId: targetChainId }],
                                    });
                                    this.addLog('success', 'ç½‘ç»œåˆ‡æ¢æˆåŠŸ');
                                } catch (addError) {
                                    this.addLog('error', `æ·»åŠ ç½‘ç»œå¤±è´¥: ${addError.message}`);
                                    throw addError;
                                }
                            } else if (switchError.code === 4001) {
                                throw new Error('ç”¨æˆ·æ‹’ç»åˆ‡æ¢ç½‘ç»œ');
                            } else {
                                throw switchError;
                            }
                        }
                    } else {
                        this.addLog('success', 'âœ… å·²åœ¨æ­£ç¡®çš„ç½‘ç»œä¸Š (Monad Testnet)');
                    }
                    
                    // æœ€ç»ˆéªŒè¯ (ä½¿ç”¨å®½æ¾åŒ¹é…)
                    const finalChainId = await window.ethereum.request({ method: 'eth_chainId' });
                    const finalMatch = finalChainId.toLowerCase() === targetChainId.toLowerCase() || 
                                      parseInt(finalChainId, 16) === targetChainIdDecimal;
                    
                    if (finalMatch) {
                        this.addLog('success', `æœ€ç»ˆéªŒè¯é€šè¿‡: ${finalChainId} (${parseInt(finalChainId, 16)})`);
                        if (finalChainId !== targetChainId) {
                            this.addLog('info', `æ³¨æ„: Chain IDå¤§å°å†™ä¸åŒä½†æ•°å€¼åŒ¹é…`);
                        }
                    } else {
                        this.addLog('error', `æœ€ç»ˆéªŒè¯å¤±è´¥: ${finalChainId} != ${targetChainId}`);
                        throw new Error(`ç½‘ç»œéªŒè¯å¤±è´¥: å½“å‰ ${finalChainId}, éœ€è¦ ${targetChainId}`);
                    }
                    
                    // åˆ›å»º provider
                    this.provider = new ethers.providers.Web3Provider(window.ethereum);
                    this.signer = this.provider.getSigner();
                    
                    // æµ‹è¯•ç½‘ç»œè¿é€šæ€§
                    this.addLog('info', 'æµ‹è¯•ç½‘ç»œè¿é€šæ€§...');
                    const balance = await this.signer.getBalance();
                    this.addLog('info', `è´¦æˆ·ä½™é¢: ${ethers.utils.formatEther(balance)} MON`);
                    
                    this.updateStatus('network', 'success', 'Monad æµ‹è¯•ç½‘ âœ…');
                    this.addLog('success', 'ç½‘ç»œè¿æ¥æ£€æµ‹é€šè¿‡');
                    return true;
                    
                } catch (error) {
                    this.updateStatus('network', 'error', 'è¿æ¥å¤±è´¥ âŒ');
                    this.addLog('error', `ç½‘ç»œè¿æ¥å¤±è´¥: ${error.message}`);
                    
                    if (error.message.includes('User rejected')) {
                        this.showSolution('âŒ ç”¨æˆ·æ“ä½œé—®é¢˜', [
                            'è¯·åœ¨ MetaMask å¼¹çª—ä¸­ç‚¹å‡»"è¿æ¥"',
                            'å…è®¸ç½‘ç«™è®¿é—®æ‚¨çš„é’±åŒ…åœ°å€',
                            'ç¡®è®¤ç½‘ç»œåˆ‡æ¢è¯·æ±‚',
                            'å¦‚æœæ²¡æœ‰çœ‹åˆ°å¼¹çª—ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨å¼¹çª—æ‹¦æˆªè®¾ç½®'
                        ]);
                    } else {
                        this.showSolution('ğŸŒ ç½‘ç»œè¿æ¥é—®é¢˜', [
                            'æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸',
                            'å°è¯•åˆ·æ–°é¡µé¢é‡æ–°è¿æ¥',
                            'ç¡®ä¿ MetaMask æ²¡æœ‰è¢«å…¶ä»–é¡µé¢å ç”¨',
                            'é‡å¯ MetaMask æ‰©å±•ç¨‹åº'
                        ]);
                    }
                    return false;
                }
            }
            
            // æ£€æµ‹åˆçº¦
            async checkContract() {
                this.addLog('info', 'å¼€å§‹éªŒè¯æ™ºèƒ½åˆçº¦...');
                this.updateStatus('contract', 'checking', 'éªŒè¯ä¸­...');
                
                try {
                    const userAddress = await this.signer.getAddress();
                    this.addLog('info', `ç”¨æˆ·åœ°å€: ${userAddress}`);
                    
                    // ç¡®å®šåˆçº¦åœ°å€
                    let contractAddress = '0xFa32A01E4FDAde90204902EDfEa63C150407C736';
                    
                    this.addLog('info', `åˆçº¦åœ°å€: ${contractAddress}`);
                    
                    // åŸºç¡€åˆçº¦ABI - åªåŒ…å«æœ€åŸºæœ¬çš„å‡½æ•°
                    const basicABI = [
                        "function name() external view returns (string)",
                        "function symbol() external view returns (string)",
                        "function totalSupply() external view returns (uint256)",
                        "function balanceOf(address account) external view returns (uint256)"
                    ];
                    
                    // åˆ›å»ºåˆçº¦å®ä¾‹
                    this.contract = new ethers.Contract(contractAddress, basicABI, this.signer);
                    
                    // æµ‹è¯•åˆçº¦è¿æ¥
                    this.addLog('info', 'æµ‹è¯•åˆçº¦åŸºç¡€åŠŸèƒ½...');
                    const name = await this.contract.name();
                    const symbol = await this.contract.symbol();
                    const totalSupply = await this.contract.totalSupply();
                    
                    this.addLog('success', `åˆçº¦åç§°: ${name}`);
                    this.addLog('success', `åˆçº¦ç¬¦å·: ${symbol}`);
                    this.addLog('success', `æ€»ä¾›åº”é‡: ${ethers.utils.formatEther(totalSupply)}`);
                    
                    this.updateStatus('contract', 'success', `${symbol} åˆçº¦ âœ…`);
                    this.addLog('success', 'æ™ºèƒ½åˆçº¦éªŒè¯é€šè¿‡');
                    return true;
                    
                } catch (error) {
                    this.updateStatus('contract', 'error', 'éªŒè¯å¤±è´¥ âŒ');
                    this.addLog('error', `åˆçº¦éªŒè¯å¤±è´¥: ${error.message}`);
                    
                    this.showSolution('ğŸ“„ åˆçº¦éªŒè¯é—®é¢˜', [
                        'æ£€æŸ¥åˆçº¦åœ°å€æ˜¯å¦æ­£ç¡®',
                        'ç¡®è®¤æ‚¨åœ¨æ­£ç¡®çš„ç½‘ç»œä¸Šï¼ˆMonad æµ‹è¯•ç½‘ï¼‰',
                        'åˆçº¦å¯èƒ½å°šæœªéƒ¨ç½²æˆ–éªŒè¯',
                        'æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒRPCèŠ‚ç‚¹çŠ¶æ€'
                    ]);
                    return false;
                }
            }
            
            // å¼€å§‹æ™ºèƒ½è¿æ¥
            async startConnection() {
                this.addLog('info', '=== å¼€å§‹æ™ºèƒ½é’±åŒ…è¿æ¥ ===');
                
                // é¦–å…ˆç¦ç”¨å…¶ä»–é’±åŒ…çš„å¹²æ‰°
                this.disableOtherWallets();
                
                // é‡ç½®çŠ¶æ€
                this.hideSolution();
                
                // è®¾ç½®æŒ‰é’®çŠ¶æ€
                const btn = document.getElementById('connectBtn');
                btn.classList.add('loading');
                btn.disabled = true;
                
                try {
                    // ç­‰å¾… ethers.js åŠ è½½
                    await this.waitForEthers();
                    
                    // æ‰§è¡Œæ£€æµ‹æ­¥éª¤
                    const browserOk = await this.checkBrowser();
                    if (!browserOk) throw new Error('æµè§ˆå™¨æ£€æµ‹å¤±è´¥');
                    
                    const metamaskOk = await this.checkMetaMask();
                    if (!metamaskOk) throw new Error('MetaMask æ£€æµ‹å¤±è´¥');
                    
                    const networkOk = await this.checkNetwork();
                    if (!networkOk) throw new Error('ç½‘ç»œè¿æ¥å¤±è´¥');
                    
                    const contractOk = await this.checkContract();
                    if (!contractOk) throw new Error('åˆçº¦éªŒè¯å¤±è´¥');
                    
                    // è¿æ¥æˆåŠŸ
                    this.addLog('success', '=== ğŸ‰ è¿æ¥å®Œå…¨æˆåŠŸï¼ ===');
                    this.hideSolution();
                    
                    // æ˜¾ç¤ºç®¡ç†é¢æ¿
                    setTimeout(() => {
                        this.showManagementPanel();
                    }, 1000);
                    
                } catch (error) {
                    this.addLog('error', `è¿æ¥å¤±è´¥: ${error.message}`);
                } finally {
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    btn.classList.remove('loading');
                    btn.disabled = false;
                }
            }
            
            // ç­‰å¾… ethers.js åŠ è½½
            async waitForEthers() {
                this.addLog('info', 'ç­‰å¾…ä¾èµ–åº“åŠ è½½...');
                
                if (typeof ethers !== 'undefined') {
                    this.addLog('success', 'Ethers.js å·²åŠ è½½');
                    return;
                }
                
                // åŠ¨æ€åŠ è½½ ethers.js
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js';
                
                return new Promise((resolve, reject) => {
                    script.onload = () => {
                        if (typeof ethers !== 'undefined') {
                            this.addLog('success', 'Ethers.js åŠ¨æ€åŠ è½½æˆåŠŸ');
                            resolve();
                        } else {
                            reject(new Error('Ethers.js åŠ è½½å¤±è´¥'));
                        }
                    };
                    script.onerror = () => reject(new Error('Ethers.js è„šæœ¬åŠ è½½å¤±è´¥'));
                    document.head.appendChild(script);
                });
            }
            
            // å·¥å…·å‡½æ•°
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            // é‡ç½®è¿æ¥
            reset() {
                this.diagnostics = {
                    browser: { status: 'pending', message: 'ç­‰å¾…æ£€æµ‹...' },
                    metamask: { status: 'pending', message: 'ç­‰å¾…æ£€æµ‹...' },
                    network: { status: 'pending', message: 'ç­‰å¾…æ£€æµ‹...' },
                    contract: { status: 'pending', message: 'ç­‰å¾…æ£€æµ‹...' }
                };
                this.logs = [];
                
                // æ›´æ–°UI
                this.updateStatus('browser', 'pending', 'ç­‰å¾…æ£€æµ‹...');
                this.updateStatus('metamask', 'pending', 'ç­‰å¾…æ£€æµ‹...');
                this.updateStatus('network', 'pending', 'ç­‰å¾…æ£€æµ‹...');
                this.updateStatus('contract', 'pending', 'ç­‰å¾…æ£€æµ‹...');
                
                this.hideSolution();
                document.getElementById('mainPanel').classList.add('hidden');
                document.getElementById('logContent').innerHTML = '';
                
                this.addLog('info', 'è¿æ¥çŠ¶æ€å·²é‡ç½®');
            }
            
            // ä¸‹è½½è¯Šæ–­æŠ¥å‘Š
            downloadReport() {
                const report = {
                    timestamp: new Date().toISOString(),
                    diagnostics: this.diagnostics,
                    logs: this.logs,
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };
                
                const blob = new Blob([JSON.stringify(report, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `fmh-wallet-diagnostic-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.addLog('success', 'è¯Šæ–­æŠ¥å‘Šå·²ä¸‹è½½');
            }
            
            // æ˜¾ç¤ºç®¡ç†é¢æ¿
            async showManagementPanel() {
                try {
                    // æ˜¾ç¤ºç®¡ç†é¢æ¿
                    document.getElementById('mainPanel').classList.remove('hidden');
                    
                    // è·å–ç”¨æˆ·åœ°å€å’Œæƒé™ä¿¡æ¯
                    const userAddress = await this.signer.getAddress();
                    const balance = await this.signer.getBalance();
                    
                    // æ›´æ–°è¿æ¥ä¿¡æ¯æ˜¾ç¤º
                    const walletInfo = document.getElementById('connectedWalletInfo');
                    walletInfo.innerHTML = `
                        <strong>åœ°å€:</strong> ${userAddress}<br>
                        <strong>ä½™é¢:</strong> ${parseFloat(ethers.utils.formatEther(balance)).toFixed(4)} MON<br>
                        <strong>ç½‘ç»œ:</strong> Monad æµ‹è¯•ç½‘
                    `;
                    
                    // è‡ªåŠ¨åˆ·æ–°åˆçº¦ä¿¡æ¯
                    await this.refreshContractInfo();
                    
                } catch (error) {
                    this.addLog('error', `æ˜¾ç¤ºç®¡ç†é¢æ¿å¤±è´¥: ${error.message}`);
                }
            }
            
            // åˆ·æ–°åˆçº¦ä¿¡æ¯
            async refreshContractInfo() {
                try {
                    this.addLog('info', 'æ­£åœ¨åˆ·æ–°åˆçº¦ä¿¡æ¯...');
                    
                    // åˆçº¦ABIå®šä¹‰
                    const contractABI = [
                        "function name() external view returns (string)",
                        "function symbol() external view returns (string)",
                        "function decimals() external view returns (uint8)",
                        "function totalSupply() external view returns (uint256)",
                        "function balanceOf(address account) external view returns (uint256)",
                        "function mint(address to, uint256 amount) external",
                        "function burn(uint256 amount) external",
                        "function burnFrom(address from, uint256 amount) external",
                        "function batchBurn(address[] calldata accounts, uint256[] calldata amounts) external",
                        "function addAuthorizedMinter(address minter) external",
                        "function removeAuthorizedMinter(address minter) external",
                        "function isAuthorizedMinter(address minter) external view returns (bool)",
                        "function getTotalBurned() external view returns (uint256)",
                        "function getBurnRate() external view returns (uint256)",
                        "function setMinesweeperGame(address _game) external",
                        "function minesweeperGame() external view returns (address)"
                    ];
                    
                    // ä½¿ç”¨å›ºå®šçš„åˆçº¦åœ°å€
                    const contractAddress = '0xFa32A01E4FDAde90204902EDfEa63C150407C736';
                    this.contract = new ethers.Contract(contractAddress, contractABI, this.signer);
                    
                    // è·å–åŸºç¡€ä¿¡æ¯
                    const [name, symbol, decimals, totalSupply] = await Promise.all([
                        this.contract.name(),
                        this.contract.symbol(),
                        this.contract.decimals(),
                        this.contract.totalSupply()
                    ]);
                    
                    let infoHTML = `
                        <div class="info-grid">
                            <div class="info-item">
                                <div class="value">${name}</div>
                                <div class="label">ä»£å¸åç§°</div>
                            </div>
                            <div class="info-item">
                                <div class="value">${symbol}</div>
                                <div class="label">ä»£å¸ç¬¦å·</div>
                            </div>
                            <div class="info-item">
                                <div class="value">${decimals}</div>
                                <div class="label">å°æ•°ä½æ•°</div>
                            </div>
                            <div class="info-item">
                                <div class="value">${this.formatToken(totalSupply)}</div>
                                <div class="label">æ€»ä¾›åº”é‡</div>
                            </div>
                    `;
                    
                    // å°è¯•è·å–é¢å¤–ä¿¡æ¯
                    try {
                        const totalBurned = await this.contract.getTotalBurned();
                        infoHTML += `
                            <div class="info-item">
                                <div class="value">${this.formatToken(totalBurned)}</div>
                                <div class="label">å·²é”€æ¯æ•°é‡</div>
                            </div>
                        `;
                    } catch (e) {
                        console.log('getTotalBurned ä¸å¯ç”¨');
                    }
                    
                    try {
                        const burnRate = await this.contract.getBurnRate();
                        infoHTML += `
                            <div class="info-item">
                                <div class="value">${(burnRate / 100).toFixed(2)}%</div>
                                <div class="label">é”€æ¯ç‡</div>
                            </div>
                        `;
                    } catch (e) {
                        console.log('getBurnRate ä¸å¯ç”¨');
                    }
                    
                    infoHTML += `</div>`;
                    document.getElementById('contractInfo').innerHTML = infoHTML;
                    
                    this.addLog('success', 'åˆçº¦ä¿¡æ¯åˆ·æ–°å®Œæˆ');
                    
                } catch (error) {
                    console.error('åˆ·æ–°åˆçº¦ä¿¡æ¯å¤±è´¥:', error);
                    document.getElementById('contractInfo').innerHTML = 
                        `<div class="status error">âŒ åˆ·æ–°å¤±è´¥: ${error.message}</div>`;
                    this.addLog('error', `åˆ·æ–°åˆçº¦ä¿¡æ¯å¤±è´¥: ${error.message}`);
                }
            }
            
            // æ ¼å¼åŒ–ä»£å¸æ•°é‡
            formatToken(amount) {
                try {
                    return parseFloat(ethers.utils.formatEther(amount)).toLocaleString('zh-CN', {
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 6
                    });
                } catch {
                    return '0';
                }
            }
        }
        
        // åˆ›å»ºå…¨å±€è¿æ¥å™¨å®ä¾‹
        const connector = new SmartWalletConnector();
        
        // é¡µé¢äº¤äº’å‡½æ•°
        function startSmartConnection() {
            connector.startConnection();
        }
        
        function resetConnection() {
            connector.reset();
        }
        
        function toggleDiagnostics() {
            const panel = document.getElementById('diagnosticPanel');
            panel.classList.toggle('show');
        }
        
        function toggleLogs() {
            const panel = document.getElementById('logPanel');
            panel.classList.toggle('show');
        }
        
        function downloadReport() {
            connector.downloadReport();
        }
        
        // å¼ºåˆ¶ä½¿ç”¨MetaMask - ç«‹å³æ‰§è¡Œç‰ˆæœ¬
        async function forceUseMetaMaskNow() {
            try {
                connector.addLog('info', 'ğŸ¦Š ç”¨æˆ·è§¦å‘å¼ºåˆ¶MetaMaskæ¨¡å¼...');
                
                const metamaskProvider = await connector.forceSelectMetaMask();
                if (metamaskProvider) {
                    // ä¸´æ—¶è¦†ç›–window.ethereum
                    window.ethereum = metamaskProvider;
                    
                    // ä¿å­˜ç”¨æˆ·åå¥½
                    localStorage.setItem('preferredWallet', 'metamask');
                    
                    // ç¦ç”¨å…¶ä»–é’±åŒ…
                    connector.disableOtherWallets();
                    
                    connector.addLog('success', 'âœ… å·²å¼ºåˆ¶åˆ‡æ¢åˆ°MetaMaskï¼');
                    alert('âœ… å·²å¼ºåˆ¶åˆ‡æ¢åˆ°MetaMaskï¼\nè¯·ç‚¹å‡»"æ™ºèƒ½è¿æ¥é’±åŒ…"é‡æ–°è¿æ¥ã€‚');
                    
                    // é‡ç½®è¿æ¥çŠ¶æ€ï¼Œè®©ç”¨æˆ·é‡æ–°è¿æ¥
                    connector.reset();
                } else {
                    connector.addLog('error', 'âŒ æœªæ‰¾åˆ°MetaMask provider');
                    alert('âŒ æœªæ‰¾åˆ°MetaMaskï¼Œè¯·ç¡®ä¿å·²å®‰è£…å¹¶å¯ç”¨MetaMaskæ‰©å±•ã€‚');
                }
            } catch (error) {
                connector.addLog('error', `å¼ºåˆ¶ä½¿ç”¨MetaMaskå¤±è´¥: ${error.message}`);
                alert('âŒ æ“ä½œå¤±è´¥: ' + error.message);
            }
        }
        
        // æ˜¾ç¤ºé’±åŒ…æ£€æµ‹æŠ¥å‘Š
        async function showWalletDetectionReport() {
            const panel = document.getElementById('walletDetectionPanel');
            const content = document.getElementById('walletDetectionContent');
            
            if (panel.classList.contains('show')) {
                panel.classList.remove('show');
                return;
            }
            
            content.innerHTML = '<div class="diagnostic-item"><div class="diagnostic-label">æ­£åœ¨æ£€æµ‹é’±åŒ…ç¯å¢ƒ...</div></div>';
            panel.classList.add('show');
            
            try {
                const detectionResult = await connector.enhancedWalletDetection();
                generateWalletDetectionReport(content, detectionResult);
            } catch (error) {
                content.innerHTML = '<div class="diagnostic-item"><div class="diagnostic-label" style="color: #ef4444;">æ£€æµ‹å¤±è´¥: ' + error.message + '</div></div>';
            }
        }
        
        // ç”Ÿæˆé’±åŒ…æ£€æµ‹æŠ¥å‘Š
        function generateWalletDetectionReport(content, results) {
            const wallets = [
                { key: 'metamask', name: 'MetaMask', icon: 'ğŸ¦Š' },
                { key: 'phantom', name: 'Phantom', icon: 'ğŸ‘»' },
                { key: 'coinbase', name: 'Coinbase Wallet', icon: 'ğŸ”·' },
                { key: 'okx', name: 'OKX Wallet', icon: 'âš«' }
            ];
            
            let reportHTML = `
                <!-- æµè§ˆå™¨ç¯å¢ƒ -->
                <div class="diagnostic-item">
                    <div class="diagnostic-label">ğŸŒ æµè§ˆå™¨ç¯å¢ƒ</div>
                    <div class="diagnostic-value">
                        <span style="color: ${results.browser.details.compatible ? '#10b981' : '#f59e0b'};">
                            ${results.browser.details.name} ${results.browser.details.version} 
                            (${results.browser.details.engine})
                            ${results.browser.details.mobile ? ' ğŸ“±' : ''}
                            ${results.browser.details.compatible ? ' âœ…' : ' âš ï¸'}
                        </span>
                    </div>
                </div>
                
                <!-- Web3 ç¯å¢ƒ -->
                <div class="diagnostic-item">
                    <div class="diagnostic-label">ğŸŒ Web3 ç¯å¢ƒ</div>
                    <div class="diagnostic-value">
                        <span style="color: ${results.web3.detected ? '#10b981' : '#ef4444'};">
                            ${results.web3.detected ? 'å·²å°±ç»ª' : 'æœªå°±ç»ª'} 
                            ${results.web3.detected ? 'âœ…' : 'âŒ'}
                            <br><small>æ£€æµ‹åˆ° ${results.web3.details.total} ä¸ªæä¾›è€…: ${results.web3.details.providers.join(', ')}</small>
                        </span>
                    </div>
                </div>
                
                <hr style="margin: 20px 0; border: 1px solid #e5e7eb;">
                
                <!-- é’±åŒ…è¯¦æƒ… -->
            `;
            
            wallets.forEach(wallet => {
                const result = results[wallet.key];
                const details = result.details;
                
                reportHTML += `
                    <div class="diagnostic-item">
                        <div class="diagnostic-label">${wallet.icon} ${wallet.name}</div>
                        <div class="diagnostic-value">
                            <div style="color: ${result.detected ? '#10b981' : '#ef4444'};">
                                ${result.detected ? 'å·²å®‰è£… âœ…' : 'æœªå®‰è£… âŒ'}
                            </div>
                `;
                
                if (result.detected) {
                    reportHTML += `<div style="font-size: 0.85em; margin-top: 4px; color: #6b7280;">`;
                    
                    if (details.version && details.version !== 'Unknown') {
                        reportHTML += `ç‰ˆæœ¬: ${details.version}<br>`;
                    }
                    
                    if (details.ready !== undefined) {
                        reportHTML += `å°±ç»ªçŠ¶æ€: ${details.ready ? 'æ˜¯' : 'å¦'}<br>`;
                    }
                    
                    if (details.conflicts && details.conflicts.length > 0) {
                        reportHTML += `<span style="color: #f59e0b;">âš ï¸ å†²çª: ${details.conflicts.join(', ')}</span><br>`;
                    }
                    
                    if (details.ethereum) {
                        reportHTML += `ğŸ”— æ”¯æŒä»¥å¤ªåŠ<br>`;
                    }
                    
                    if (details.solana) {
                        reportHTML += `ğŸ”— æ”¯æŒSolana<br>`;
                    }
                    
                    if (details.mobile) {
                        reportHTML += `ğŸ“± ç§»åŠ¨ç«¯ç‰ˆæœ¬<br>`;
                    }
                    
                    reportHTML += `</div>`;
                }
                
                reportHTML += `
                        </div>
                    </div>
                `;
            });
            
            // æ™ºèƒ½æ¨è
            const recommendations = generateSmartRecommendations(results);
            reportHTML += `
                <hr style="margin: 20px 0; border: 1px solid #e5e7eb;">
                <div class="diagnostic-item">
                    <div class="diagnostic-label">ğŸ’¡ æ™ºèƒ½å»ºè®®</div>
                    <div class="diagnostic-value">
                        ${recommendations.map(rec => `<div style="margin: 4px 0; color: #374151;">â€¢ ${rec}</div>`).join('')}
                    </div>
                </div>
            `;
            
            content.innerHTML = reportHTML;
        }
        
        // ç”Ÿæˆæ™ºèƒ½æ¨è
        function generateSmartRecommendations(results) {
            const recommendations = [];
            
            // æµè§ˆå™¨å…¼å®¹æ€§å»ºè®®
            if (!results.browser.details.compatible) {
                recommendations.push('å»ºè®®ä½¿ç”¨ Chromeã€Edge æˆ– Firefox æµè§ˆå™¨ä»¥è·å¾—æœ€ä½³ Web3 ä½“éªŒ');
            }
            
            // MetaMask ç›¸å…³å»ºè®®
            if (!results.metamask.detected) {
                recommendations.push('å»ºè®®å®‰è£… MetaMask - æœ€å¹¿æ³›æ”¯æŒçš„ä»¥å¤ªåŠé’±åŒ…');
            } else if (results.metamask.details.conflicts.length > 0) {
                recommendations.push('æ£€æµ‹åˆ°å¤šé’±åŒ…å†²çªï¼Œå»ºè®®ç¦ç”¨å…¶ä»–é’±åŒ…æ‰©å±•ä»¥é¿å…è¿æ¥é—®é¢˜');
            }
            
            // å¤šé’±åŒ…ç¯å¢ƒå»ºè®®
            if (results.web3.details.total > 1) {
                recommendations.push('æ£€æµ‹åˆ°å¤šä¸ªé’±åŒ…æ’ä»¶ï¼Œå»ºè®®åªä¿ç•™ä¸€ä¸ªä¸»è¦é’±åŒ…ä»¥é¿å…å†²çª');
            }
            
            // ç§»åŠ¨ç«¯å»ºè®®
            if (results.browser.details.mobile) {
                recommendations.push('ç§»åŠ¨ç«¯ç”¨æˆ·å»ºè®®ä½¿ç”¨é’±åŒ…å†…ç½®æµè§ˆå™¨è®¿é—® DApp');
            }
            
            // æ— é’±åŒ…å»ºè®®
            if (results.web3.details.total === 0) {
                recommendations.push('æœªæ£€æµ‹åˆ°ä»»ä½• Web3 é’±åŒ…ï¼Œå»ºè®®å®‰è£… MetaMask æˆ–å…¶ä»–æ”¯æŒçš„é’±åŒ…');
            }
            
            // æˆåŠŸè¿æ¥çš„æƒ…å†µ
            if (results.metamask.detected && results.metamask.details.ready && results.browser.details.compatible) {
                recommendations.push('æ‚¨çš„ç¯å¢ƒé…ç½®è‰¯å¥½ï¼Œå¯ä»¥æ­£å¸¸ä½¿ç”¨ FMH ä»£å¸ç®¡ç†åŠŸèƒ½');
            }
            
            return recommendations;
        }
        
        // ç®¡ç†åŠŸèƒ½å‡½æ•°
        async function refreshContractInfo() {
            if (connector.contract) {
                await connector.refreshContractInfo();
            }
        }
        
        async function mintTokens() {
            try {
                const toAddress = document.getElementById('mintToAddress').value.trim();
                const amount = document.getElementById('mintAmount').value.trim();
                
                if (!toAddress || !amount) {
                    showStatus('mintStatus', 'error', 'âŒ è¯·å¡«å†™å®Œæ•´çš„é“¸å¸ä¿¡æ¯');
                    return;
                }
                
                if (!ethers.utils.isAddress(toAddress)) {
                    showStatus('mintStatus', 'error', 'âŒ æ¥æ”¶åœ°å€æ ¼å¼é”™è¯¯');
                    return;
                }
                
                if (parseFloat(amount) <= 0) {
                    showStatus('mintStatus', 'error', 'âŒ é“¸å¸æ•°é‡å¿…é¡»å¤§äº0');
                    return;
                }
                
                showStatus('mintStatus', 'info', 'â³ æ­£åœ¨å¤„ç†é“¸å¸äº¤æ˜“ï¼Œè¯·åœ¨é’±åŒ…ä¸­ç¡®è®¤...');
                
                const mintAmount = ethers.utils.parseEther(amount);
                const tx = await connector.contract.mint(toAddress, mintAmount);
                
                showStatus('mintStatus', 'info', `â³ äº¤æ˜“å·²æäº¤ï¼Œç­‰å¾…ç¡®è®¤...<br><small>äº¤æ˜“å“ˆå¸Œ: ${tx.hash}</small>`);
                
                const receipt = await tx.wait();
                showStatus('mintStatus', 'success', `âœ… é“¸å¸æˆåŠŸï¼<br>å·²å‘ ${toAddress} é“¸é€  ${amount} FMH<br><small>Gasè´¹ç”¨: ${receipt.gasUsed.toString()}</small>`);
                
                document.getElementById('mintToAddress').value = '';
                document.getElementById('mintAmount').value = '';
                await refreshContractInfo();
                
            } catch (error) {
                console.error('é“¸å¸å¤±è´¥:', error);
                showStatus('mintStatus', 'error', `âŒ é“¸å¸å¤±è´¥: ${error.message}`);
            }
        }
        
        function toggleBurnInputs() {
            const burnType = document.getElementById('burnType').value;
            const burnFromGroup = document.getElementById('burnFromGroup');
            
            if (burnType === 'burnFrom') {
                burnFromGroup.style.display = 'block';
            } else {
                burnFromGroup.style.display = 'none';
            }
        }
        
        async function burnTokens() {
            try {
                const burnType = document.getElementById('burnType').value;
                const amount = document.getElementById('burnAmount').value.trim();
                
                if (!amount) {
                    showStatus('burnStatus', 'error', 'âŒ è¯·è¾“å…¥é”€æ¯æ•°é‡');
                    return;
                }
                
                if (parseFloat(amount) <= 0) {
                    showStatus('burnStatus', 'error', 'âŒ é”€æ¯æ•°é‡å¿…é¡»å¤§äº0');
                    return;
                }
                
                const burnAmount = ethers.utils.parseEther(amount);
                let tx;
                
                if (burnType === 'burn') {
                    if (!confirm(`ç¡®è®¤è¦é”€æ¯æ‚¨çš„ ${amount} FMH ä»£å¸å—ï¼Ÿ\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼`)) {
                        return;
                    }
                    
                    showStatus('burnStatus', 'warning', 'â³ æ­£åœ¨é”€æ¯æ‚¨çš„ä»£å¸...');
                    tx = await connector.contract.burn(burnAmount);
                    
                } else {
                    const fromAddress = document.getElementById('burnFromAddress').value.trim();
                    
                    if (!fromAddress || !ethers.utils.isAddress(fromAddress)) {
                        showStatus('burnStatus', 'error', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„ç›®æ ‡åœ°å€');
                        return;
                    }
                    
                    if (!confirm(`ç¡®è®¤è¦é”€æ¯ ${fromAddress} çš„ ${amount} FMH ä»£å¸å—ï¼Ÿ\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼`)) {
                        return;
                    }
                    
                    showStatus('burnStatus', 'warning', 'â³ æ­£åœ¨é”€æ¯ç›®æ ‡åœ°å€çš„ä»£å¸...');
                    tx = await connector.contract.burnFrom(fromAddress, burnAmount);
                }
                
                showStatus('burnStatus', 'info', `â³ äº¤æ˜“å·²æäº¤ï¼Œç­‰å¾…ç¡®è®¤...<br><small>äº¤æ˜“å“ˆå¸Œ: ${tx.hash}</small>`);
                
                await tx.wait();
                showStatus('burnStatus', 'success', `âœ… ä»£å¸é”€æ¯æˆåŠŸï¼<br>å·²é”€æ¯ ${amount} FMH`);
                
                document.getElementById('burnAmount').value = '';
                document.getElementById('burnFromAddress').value = '';
                await refreshContractInfo();
                
            } catch (error) {
                console.error('é”€æ¯å¤±è´¥:', error);
                showStatus('burnStatus', 'error', `âŒ é”€æ¯å¤±è´¥: ${error.message}`);
            }
        }
        
        function addBatchItem() {
            const batchList = document.getElementById('batchBurnList');
            const newItem = document.createElement('div');
            newItem.className = 'batch-item';
            newItem.innerHTML = `
                <input type="text" placeholder="åœ°å€ (0x...)" class="batch-address">
                <input type="number" placeholder="æ•°é‡" class="batch-amount" min="0" step="0.001">
                <button class="btn btn-danger btn-small" onclick="removeBatchItem(this)">åˆ é™¤</button>
            `;
            batchList.appendChild(newItem);
        }
        
        function removeBatchItem(button) {
            const batchList = document.getElementById('batchBurnList');
            if (batchList.children.length > 1) {
                button.parentElement.remove();
            } else {
                showStatus('batchBurnStatus', 'warning', 'âš ï¸ è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªé¡¹ç›®');
            }
        }
        
        async function executeBatchBurn() {
            try {
                const batchItems = document.querySelectorAll('.batch-item');
                const addresses = [];
                const amounts = [];
                
                for (let item of batchItems) {
                    const address = item.querySelector('.batch-address').value.trim();
                    const amount = item.querySelector('.batch-amount').value.trim();
                    
                    if (address && amount) {
                        if (!ethers.utils.isAddress(address)) {
                            showStatus('batchBurnStatus', 'error', `âŒ åœ°å€æ ¼å¼é”™è¯¯: ${address}`);
                            return;
                        }
                        
                        if (parseFloat(amount) <= 0) {
                            showStatus('batchBurnStatus', 'error', `âŒ æ•°é‡å¿…é¡»å¤§äº0: ${amount}`);
                            return;
                        }
                        
                        addresses.push(address);
                        amounts.push(ethers.utils.parseEther(amount));
                    }
                }
                
                if (addresses.length === 0) {
                    showStatus('batchBurnStatus', 'error', 'âŒ è¯·è‡³å°‘å¡«å†™ä¸€ä¸ªæœ‰æ•ˆçš„åœ°å€å’Œæ•°é‡');
                    return;
                }
                
                const totalAmount = amounts.reduce((sum, amt) => sum.add(amt), ethers.BigNumber.from(0));
                const totalFormatted = ethers.utils.formatEther(totalAmount);
                
                if (!confirm(`ç¡®è®¤è¦æ‰¹é‡é”€æ¯æ€»å…± ${totalFormatted} FMH ä»£å¸å—ï¼Ÿ\næ¶‰åŠ ${addresses.length} ä¸ªåœ°å€\n\nâš ï¸ æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼`)) {
                    return;
                }
                
                showStatus('batchBurnStatus', 'warning', 'â³ æ­£åœ¨æ‰§è¡Œæ‰¹é‡é”€æ¯...');
                
                const tx = await connector.contract.batchBurn(addresses, amounts);
                showStatus('batchBurnStatus', 'info', `â³ äº¤æ˜“å·²æäº¤ï¼Œç­‰å¾…ç¡®è®¤...<br><small>äº¤æ˜“å“ˆå¸Œ: ${tx.hash}</small>`);
                
                await tx.wait();
                showStatus('batchBurnStatus', 'success', `âœ… æ‰¹é‡é”€æ¯æˆåŠŸï¼<br>å…±é”€æ¯ ${totalFormatted} FMH (${addresses.length} ä¸ªåœ°å€)`);
                
                document.querySelectorAll('.batch-address').forEach(input => input.value = '');
                document.querySelectorAll('.batch-amount').forEach(input => input.value = '');
                await refreshContractInfo();
                
            } catch (error) {
                console.error('æ‰¹é‡é”€æ¯å¤±è´¥:', error);
                showStatus('batchBurnStatus', 'error', `âŒ æ‰¹é‡é”€æ¯å¤±è´¥: ${error.message}`);
            }
        }
        
        async function addMinter() {
            try {
                const minterAddress = document.getElementById('newMinterAddress').value.trim();
                
                if (!minterAddress || !ethers.utils.isAddress(minterAddress)) {
                    showStatus('minterStatus', 'error', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„åœ°å€');
                    return;
                }
                
                showStatus('minterStatus', 'info', 'â³ æ­£åœ¨æ·»åŠ é“¸å¸è€…...');
                
                const tx = await connector.contract.addAuthorizedMinter(minterAddress);
                showStatus('minterStatus', 'info', `â³ äº¤æ˜“å·²æäº¤ï¼Œç­‰å¾…ç¡®è®¤...<br><small>äº¤æ˜“å“ˆå¸Œ: ${tx.hash}</small>`);
                
                await tx.wait();
                showStatus('minterStatus', 'success', `âœ… é“¸å¸è€…æ·»åŠ æˆåŠŸï¼<br>${minterAddress} ç°åœ¨æ‹¥æœ‰é“¸å¸æƒé™`);
                
                document.getElementById('newMinterAddress').value = '';
                
            } catch (error) {
                console.error('æ·»åŠ é“¸å¸è€…å¤±è´¥:', error);
                showStatus('minterStatus', 'error', `âŒ æ·»åŠ é“¸å¸è€…å¤±è´¥: ${error.message}`);
            }
        }
        
        async function removeMinter() {
            try {
                const minterAddress = document.getElementById('removeMinterAddress').value.trim();
                
                if (!minterAddress || !ethers.utils.isAddress(minterAddress)) {
                    showStatus('minterStatus', 'error', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„åœ°å€');
                    return;
                }
                
                if (!confirm(`ç¡®è®¤è¦ç§»é™¤ ${minterAddress} çš„é“¸å¸æƒé™å—ï¼Ÿ`)) {
                    return;
                }
                
                showStatus('minterStatus', 'info', 'â³ æ­£åœ¨ç§»é™¤é“¸å¸è€…...');
                
                const tx = await connector.contract.removeAuthorizedMinter(minterAddress);
                await tx.wait();
                
                showStatus('minterStatus', 'success', `âœ… é“¸å¸è€…ç§»é™¤æˆåŠŸï¼<br>${minterAddress} çš„é“¸å¸æƒé™å·²è¢«æ’¤é”€`);
                
                document.getElementById('removeMinterAddress').value = '';
                
            } catch (error) {
                console.error('ç§»é™¤é“¸å¸è€…å¤±è´¥:', error);
                showStatus('minterStatus', 'error', `âŒ ç§»é™¤é“¸å¸è€…å¤±è´¥: ${error.message}`);
            }
        }
        
        async function checkMinterPermission() {
            try {
                const checkAddress = document.getElementById('checkMinterAddress').value.trim();
                
                if (!checkAddress || !ethers.utils.isAddress(checkAddress)) {
                    showStatus('minterStatus', 'error', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„åœ°å€');
                    return;
                }
                
                const isMinter = await connector.contract.isAuthorizedMinter(checkAddress);
                
                let statusText = `ğŸ” æƒé™æŸ¥è¯¢ç»“æœ:<br><strong>åœ°å€:</strong> ${checkAddress}<br>`;
                statusText += `<strong>é“¸å¸æƒé™:</strong> ${isMinter ? 'âœ… æ˜¯' : 'âŒ å¦'}`;
                
                showStatus('minterStatus', 'info', statusText);
                
            } catch (error) {
                console.error('æƒé™æ£€æŸ¥å¤±è´¥:', error);
                showStatus('minterStatus', 'error', `âŒ æƒé™æ£€æŸ¥å¤±è´¥: ${error.message}`);
            }
        }
        
        async function queryBalance() {
            try {
                const queryAddr = document.getElementById('queryAddress').value.trim();
                
                if (!queryAddr || !ethers.utils.isAddress(queryAddr)) {
                    showStatus('queryResults', 'error', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„åœ°å€');
                    return;
                }
                
                showLoading('queryResults');
                
                const balance = await connector.contract.balanceOf(queryAddr);
                
                showStatus('queryResults', 'info', `ğŸ’° ä½™é¢æŸ¥è¯¢ç»“æœ:<br><strong>åœ°å€:</strong> ${queryAddr}<br><strong>FMHä½™é¢:</strong> ${connector.formatToken(balance)}`);
                
            } catch (error) {
                console.error('ä½™é¢æŸ¥è¯¢å¤±è´¥:', error);
                showStatus('queryResults', 'error', `âŒ ä½™é¢æŸ¥è¯¢å¤±è´¥: ${error.message}`);
            }
        }
        
        async function getBurnRate() {
            try {
                showLoading('queryResults');
                
                const [totalSupply, totalBurned, burnRate] = await Promise.all([
                    connector.contract.totalSupply(),
                    connector.contract.getTotalBurned(),
                    connector.contract.getBurnRate()
                ]);
                
                let resultText = `ğŸ“ˆ é”€æ¯ç»Ÿè®¡ä¿¡æ¯:<br>`;
                resultText += `<strong>æ€»ä¾›åº”é‡:</strong> ${connector.formatToken(totalSupply)}<br>`;
                resultText += `<strong>å·²é”€æ¯æ•°é‡:</strong> ${connector.formatToken(totalBurned)}<br>`;
                resultText += `<strong>é”€æ¯ç‡:</strong> ${(burnRate / 100).toFixed(2)}%`;
                
                showStatus('queryResults', 'info', resultText);
                
            } catch (error) {
                console.error('è·å–é”€æ¯ç‡å¤±è´¥:', error);
                showStatus('queryResults', 'error', `âŒ è·å–é”€æ¯ç‡å¤±è´¥: ${error.message}`);
            }
        }
        
        async function setGameContract() {
            try {
                const gameAddress = document.getElementById('gameContractAddress').value.trim();
                
                if (!gameAddress || !ethers.utils.isAddress(gameAddress)) {
                    showStatus('settingsStatus', 'error', 'âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ¸¸æˆåˆçº¦åœ°å€');
                    return;
                }
                
                if (!confirm(`ç¡®è®¤è¦è®¾ç½®æ¸¸æˆåˆçº¦åœ°å€ä¸º:\n${gameAddress}\n\nè¿™å°†å½±å“æ¸¸æˆç›¸å…³çš„ä»£å¸æ“ä½œã€‚`)) {
                    return;
                }
                
                showStatus('settingsStatus', 'info', 'â³ æ­£åœ¨æ›´æ–°æ¸¸æˆåˆçº¦åœ°å€...');
                
                const tx = await connector.contract.setMinesweeperGame(gameAddress);
                showStatus('settingsStatus', 'info', `â³ äº¤æ˜“å·²æäº¤ï¼Œç­‰å¾…ç¡®è®¤...<br><small>äº¤æ˜“å“ˆå¸Œ: ${tx.hash}</small>`);
                
                await tx.wait();
                showStatus('settingsStatus', 'success', `âœ… æ¸¸æˆåˆçº¦åœ°å€è®¾ç½®æˆåŠŸï¼<br>æ–°åœ°å€: ${gameAddress}`);
                
                document.getElementById('gameContractAddress').value = '';
                await refreshContractInfo();
                
            } catch (error) {
                console.error('è®¾ç½®æ¸¸æˆåˆçº¦å¤±è´¥:', error);
                showStatus('settingsStatus', 'error', `âŒ è®¾ç½®æ¸¸æˆåˆçº¦å¤±è´¥: ${error.message}`);
            }
        }
        
        async function getCurrentGameContract() {
            try {
                showLoading('settingsStatus');
                
                const gameContract = await connector.contract.minesweeperGame();
                
                let statusText = `ğŸ® å½“å‰æ¸¸æˆåˆçº¦ä¿¡æ¯:<br><strong>åœ°å€:</strong> `;
                if (gameContract === '0x0000000000000000000000000000000000000000') {
                    statusText += 'æœªè®¾ç½®æ¸¸æˆåˆçº¦';
                } else {
                    statusText += gameContract;
                }
                
                showStatus('settingsStatus', 'info', statusText);
                
            } catch (error) {
                console.error('æŸ¥è¯¢æ¸¸æˆåˆçº¦å¤±è´¥:', error);
                showStatus('settingsStatus', 'error', `âŒ æŸ¥è¯¢æ¸¸æˆåˆçº¦å¤±è´¥: ${error.message}`);
            }
        }
        
        // å·¥å…·å‡½æ•°
        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            if (element) {
                element.innerHTML = `<div class="status ${type}">${message}</div>`;
            }
        }
        
        function showLoading(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.innerHTML = `<div class="status info"><div style="display: inline-block; width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #667eea; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 10px;"></div>æ­£åœ¨åŠ è½½...</div>`;
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            connector.addLog('info', 'é¡µé¢åŠ è½½å®Œæˆï¼Œæ™ºèƒ½è¿æ¥ç³»ç»Ÿå·²å°±ç»ª');
        });
    </script>
</body>
</html>